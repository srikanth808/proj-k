{"ast":null,"code":"import{useEffect,useRef,useState,useCallback}from'react';export const useWebSocket=_ref=>{let{url,onMessage,onOpen,onClose,onError,reconnectAttempts=5,reconnectInterval=3000}=_ref;const[isConnected,setIsConnected]=useState(false);const[lastMessage,setLastMessage]=useState(null);const ws=useRef(null);const reconnectTimeoutId=useRef(null);const reconnectCount=useRef(0);const connect=useCallback(()=>{try{ws.current=new WebSocket(url);ws.current.onopen=()=>{setIsConnected(true);reconnectCount.current=0;onOpen===null||onOpen===void 0?void 0:onOpen();};ws.current.onmessage=event=>{try{const message=JSON.parse(event.data);setLastMessage(message);onMessage===null||onMessage===void 0?void 0:onMessage(message);}catch(error){console.error('Failed to parse WebSocket message:',error);}};ws.current.onclose=()=>{setIsConnected(false);onClose===null||onClose===void 0?void 0:onClose();// Attempt to reconnect if not at max attempts\nif(reconnectCount.current<reconnectAttempts){reconnectCount.current+=1;reconnectTimeoutId.current=setTimeout(()=>{connect();},reconnectInterval);}};ws.current.onerror=error=>{console.error('WebSocket error:',error);onError===null||onError===void 0?void 0:onError(error);};}catch(error){console.error('Failed to create WebSocket connection:',error);}},[url,onMessage,onOpen,onClose,onError,reconnectAttempts,reconnectInterval]);const disconnect=useCallback(()=>{if(reconnectTimeoutId.current){clearTimeout(reconnectTimeoutId.current);}if(ws.current){ws.current.close();}},[]);const sendMessage=useCallback(message=>{if(ws.current&&ws.current.readyState===WebSocket.OPEN){ws.current.send(JSON.stringify(message));}else{console.warn('WebSocket is not connected');}},[]);useEffect(()=>{connect();return()=>{disconnect();};},[connect,disconnect]);return{isConnected,lastMessage,sendMessage,disconnect,reconnect:connect};};","map":{"version":3,"names":["useEffect","useRef","useState","useCallback","useWebSocket","_ref","url","onMessage","onOpen","onClose","onError","reconnectAttempts","reconnectInterval","isConnected","setIsConnected","lastMessage","setLastMessage","ws","reconnectTimeoutId","reconnectCount","connect","current","WebSocket","onopen","onmessage","event","message","JSON","parse","data","error","console","onclose","setTimeout","onerror","disconnect","clearTimeout","close","sendMessage","readyState","OPEN","send","stringify","warn","reconnect"],"sources":["S:/proj k/frontend/src/hooks/useWebSocket.ts"],"sourcesContent":["import { useEffect, useRef, useState, useCallback } from 'react';\r\n\r\ninterface WebSocketMessage {\r\n  type: string;\r\n  data?: any;\r\n}\r\n\r\ninterface UseWebSocketOptions {\r\n  url: string;\r\n  onMessage?: (message: WebSocketMessage) => void;\r\n  onOpen?: () => void;\r\n  onClose?: () => void;\r\n  onError?: (error: Event) => void;\r\n  reconnectAttempts?: number;\r\n  reconnectInterval?: number;\r\n}\r\n\r\nexport const useWebSocket = ({\r\n  url,\r\n  onMessage,\r\n  onOpen,\r\n  onClose,\r\n  onError,\r\n  reconnectAttempts = 5,\r\n  reconnectInterval = 3000,\r\n}: UseWebSocketOptions) => {\r\n  const [isConnected, setIsConnected] = useState(false);\r\n  const [lastMessage, setLastMessage] = useState<WebSocketMessage | null>(null);\r\n  const ws = useRef<WebSocket | null>(null);\r\n  const reconnectTimeoutId = useRef<NodeJS.Timeout | null>(null);\r\n  const reconnectCount = useRef(0);\r\n\r\n  const connect = useCallback(() => {\r\n    try {\r\n      ws.current = new WebSocket(url);\r\n\r\n      ws.current.onopen = () => {\r\n        setIsConnected(true);\r\n        reconnectCount.current = 0;\r\n        onOpen?.();\r\n      };\r\n\r\n      ws.current.onmessage = (event) => {\r\n        try {\r\n          const message: WebSocketMessage = JSON.parse(event.data);\r\n          setLastMessage(message);\r\n          onMessage?.(message);\r\n        } catch (error) {\r\n          console.error('Failed to parse WebSocket message:', error);\r\n        }\r\n      };\r\n\r\n      ws.current.onclose = () => {\r\n        setIsConnected(false);\r\n        onClose?.();\r\n\r\n        // Attempt to reconnect if not at max attempts\r\n        if (reconnectCount.current < reconnectAttempts) {\r\n          reconnectCount.current += 1;\r\n          reconnectTimeoutId.current = setTimeout(() => {\r\n            connect();\r\n          }, reconnectInterval);\r\n        }\r\n      };\r\n\r\n      ws.current.onerror = (error) => {\r\n        console.error('WebSocket error:', error);\r\n        onError?.(error);\r\n      };\r\n    } catch (error) {\r\n      console.error('Failed to create WebSocket connection:', error);\r\n    }\r\n  }, [url, onMessage, onOpen, onClose, onError, reconnectAttempts, reconnectInterval]);\r\n\r\n  const disconnect = useCallback(() => {\r\n    if (reconnectTimeoutId.current) {\r\n      clearTimeout(reconnectTimeoutId.current);\r\n    }\r\n    if (ws.current) {\r\n      ws.current.close();\r\n    }\r\n  }, []);\r\n\r\n  const sendMessage = useCallback((message: any) => {\r\n    if (ws.current && ws.current.readyState === WebSocket.OPEN) {\r\n      ws.current.send(JSON.stringify(message));\r\n    } else {\r\n      console.warn('WebSocket is not connected');\r\n    }\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    connect();\r\n\r\n    return () => {\r\n      disconnect();\r\n    };\r\n  }, [connect, disconnect]);\r\n\r\n  return {\r\n    isConnected,\r\n    lastMessage,\r\n    sendMessage,\r\n    disconnect,\r\n    reconnect: connect,\r\n  };\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}